{"ast":null,"code":"// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { Log, TransactionReceipt, TransactionResponse } from \"../providers/provider.js\";\nimport { defineProperties, EventPayload } from \"../utils/index.js\";\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nexport class EventLog extends Log {\n  /**\n   *  The Contract Interface.\n   */\n  interface;\n  /**\n   *  The matching event.\n   */\n  fragment;\n  /**\n   *  The parsed arguments passed to the event by ``emit``.\n   */\n  args;\n  /**\n   * @_ignore:\n   */\n  constructor(log, iface, fragment) {\n    super(log, log.provider);\n    const args = iface.decodeEventLog(fragment, log.data, log.topics);\n    defineProperties(this, {\n      args,\n      fragment,\n      interface: iface\n    });\n  }\n  /**\n   *  The name of the event.\n   */\n  get eventName() {\n    return this.fragment.name;\n  }\n  /**\n   *  The signature of the event.\n   */\n  get eventSignature() {\n    return this.fragment.format();\n  }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nexport class UndecodedEventLog extends Log {\n  /**\n   *  The error encounted when trying to decode the log.\n   */\n  error;\n  /**\n   * @_ignore:\n   */\n  constructor(log, error) {\n    super(log, log.provider);\n    defineProperties(this, {\n      error\n    });\n  }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nexport class ContractTransactionReceipt extends TransactionReceipt {\n  #iface;\n  /**\n   *  @_ignore:\n   */\n  constructor(iface, provider, tx) {\n    super(tx, provider);\n    this.#iface = iface;\n  }\n  /**\n   *  The parsed logs for any [[Log]] which has a matching event in the\n   *  Contract ABI.\n   */\n  get logs() {\n    return super.logs.map(log => {\n      const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n      if (fragment) {\n        try {\n          return new EventLog(log, this.#iface, fragment);\n        } catch (error) {\n          return new UndecodedEventLog(log, error);\n        }\n      }\n      return log;\n    });\n  }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nexport class ContractTransactionResponse extends TransactionResponse {\n  #iface;\n  /**\n   *  @_ignore:\n   */\n  constructor(iface, provider, tx) {\n    super(tx, provider);\n    this.#iface = iface;\n  }\n  /**\n   *  Resolves once this transaction has been mined and has\n   *  %%confirms%% blocks including it (default: ``1``) with an\n   *  optional %%timeout%%.\n   *\n   *  This can resolve to ``null`` only if %%confirms%% is ``0``\n   *  and the transaction has not been mined, otherwise this will\n   *  wait until enough confirmations have completed.\n   */\n  async wait(confirms) {\n    const receipt = await super.wait(confirms);\n    if (receipt == null) {\n      return null;\n    }\n    return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n  }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nexport class ContractUnknownEventPayload extends EventPayload {\n  /**\n   *  The log with no matching events.\n   */\n  log;\n  /**\n   *  @_event:\n   */\n  constructor(contract, listener, filter, log) {\n    super(contract, listener, filter);\n    defineProperties(this, {\n      log\n    });\n  }\n  /**\n   *  Resolves to the block the event occured in.\n   */\n  async getBlock() {\n    return await this.log.getBlock();\n  }\n  /**\n   *  Resolves to the transaction the event occured in.\n   */\n  async getTransaction() {\n    return await this.log.getTransaction();\n  }\n  /**\n   *  Resolves to the transaction receipt the event occured in.\n   */\n  async getTransactionReceipt() {\n    return await this.log.getTransactionReceipt();\n  }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nexport class ContractEventPayload extends ContractUnknownEventPayload {\n  /**\n   *  @_ignore:\n   */\n  constructor(contract, listener, filter, fragment, _log) {\n    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n    defineProperties(this, {\n      args,\n      fragment\n    });\n  }\n  /**\n   *  The event name.\n   */\n  get eventName() {\n    return this.fragment.name;\n  }\n  /**\n   *  The event signature.\n   */\n  get eventSignature() {\n    return this.fragment.format();\n  }\n}","map":{"version":3,"names":["Log","TransactionReceipt","TransactionResponse","defineProperties","EventPayload","EventLog","interface","fragment","args","constructor","log","iface","provider","decodeEventLog","data","topics","eventName","name","eventSignature","format","UndecodedEventLog","error","ContractTransactionReceipt","tx","logs","map","length","getEvent","ContractTransactionResponse","wait","confirms","receipt","ContractUnknownEventPayload","contract","listener","filter","getBlock","getTransaction","getTransactionReceipt","ContractEventPayload","_log"],"sources":["C:/Users/hikme/OneDrive/Masaüstü/metamask-connection/metamask-connection/node_modules/ethers/lib.esm/contract/wrappers.js"],"sourcesContent":["// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { Log, TransactionReceipt, TransactionResponse } from \"../providers/provider.js\";\nimport { defineProperties, EventPayload } from \"../utils/index.js\";\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nexport class EventLog extends Log {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The matching event.\n     */\n    fragment;\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    args;\n    /**\n     * @_ignore:\n     */\n    constructor(log, iface, fragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        defineProperties(this, { args, fragment, interface: iface });\n    }\n    /**\n     *  The name of the event.\n     */\n    get eventName() { return this.fragment.name; }\n    /**\n     *  The signature of the event.\n     */\n    get eventSignature() { return this.fragment.format(); }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nexport class UndecodedEventLog extends Log {\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    error;\n    /**\n     * @_ignore:\n     */\n    constructor(log, error) {\n        super(log, log.provider);\n        defineProperties(this, { error });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nexport class ContractTransactionReceipt extends TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */\n    get logs() {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                }\n                catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nexport class ContractTransactionResponse extends TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(confirms) {\n        const receipt = await super.wait(confirms);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nexport class ContractUnknownEventPayload extends EventPayload {\n    /**\n     *  The log with no matching events.\n     */\n    log;\n    /**\n     *  @_event:\n     */\n    constructor(contract, listener, filter, log) {\n        super(contract, listener, filter);\n        defineProperties(this, { log });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */\n    async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */\n    async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */\n    async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nexport class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */\n    constructor(contract, listener, filter, fragment, _log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        defineProperties(this, { args, fragment });\n    }\n    /**\n     *  The event name.\n     */\n    get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */\n    get eventSignature() {\n        return this.fragment.format();\n    }\n}\n//# sourceMappingURL=wrappers.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}